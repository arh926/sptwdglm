% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spssdglm.autograd.R
\name{spssdglm.autograd}
\alias{spssdglm.autograd}
\title{Tweedie Compound Poisson-Gamma (CP-g) Double Generalized Linear Spatial Process Models}
\usage{
spssdglm.autograd(
  coords = NULL,
  y = NULL,
  x = NULL,
  z = NULL,
  index = NULL,
  beta.init = NULL,
  w.init = NULL,
  gamma.init = NULL,
  xi.init = NULL,
  alpha.beta.init = NULL,
  alpha.gamma.init = NULL,
  zeta.beta.init = NULL,
  zeta.gamma.init = NULL,
  sigma2.beta.init = NULL,
  sigma2.gamma.init = NULL,
  shape.sigma2.beta = NULL,
  shape.sigma2.gamma = NULL,
  rate.sigma2.beta = NULL,
  rate.sigma2.gamma = NULL,
  sigma2.init = NULL,
  phis.init = NULL,
  lower.xi = NULL,
  upper.xi = NULL,
  shape.sigma2 = NULL,
  scale.sigma2 = NULL,
  lower.phis = NULL,
  upper.phis = NULL,
  nu0 = 5e-04,
  tau.beta = 0.1,
  tau.gamma = 0.1,
  tau.xi = 0.1,
  tau.phis = 0.1,
  niter = NULL,
  nburn = NULL,
  report = NULL,
  thin = 1,
  return.mcmc = TRUE,
  verbose = FALSE,
  digits = 3,
  reg.factor = 0,
  reg.factor.sp = 0
)
}
\arguments{
\item{coords}{coordinates for observed process (ex. latitude-longitude)}

\item{y}{observed response}

\item{x}{covariates for the mean model}

\item{z}{covariates for the dispersion model}

\item{lower.xi}{lower bound for the index parameter, \eqn{\xi}}

\item{upper.xi}{upper bound for the index parameter, \eqn{\xi}}
}
\description{

}
\examples{
\dontrun{
require(tweedie)
require(mvtnorm)
require(MASS)

# Generate Data
N = 1e4
L = 1e2

coords = matrix(runif(2*L), nc=2)
par(mfcol=c(1,1))
# plot(coords)
sigma2.true = 1
phis.true = 3
Delta = as.matrix(dist(coords))
Sigma = sigma2.true*exp(-phis.true*Delta)
w.true = mvrnorm(1, rep(0, L), Sigma)

if(N > L) index = sample(1:L, N, replace = TRUE) else if(N == L) index = sample(1:L, N, replace = FALSE)

# Design matrices
z = x = cbind(1, rnorm(N), rnorm(N), rnorm(N), rnorm(N), rnorm(N), rnorm(N))
x[,-1] = apply(x[,-1], 2, function(s) (s - mean(s))/sd(s))
z[,-1] = apply(z[,-1], 2, function(s) (s - mean(s))/sd(s))

p = ncol(x)
q = ncol(z)

# covariates
beta0 = 1
beta1 = 1.5
beta2 = 0.01
beta3 = 1.4
beta4 = 1.1
beta5 = 0.01
beta6 = 2.5
beta.true = c(beta0, beta1, beta2, beta3, beta4, beta5, beta6)
mu_sim.sp = exp(x \%*\% beta.true + w.true[index])
gamma0 = 1
gamma1 = 0.01
gamma2 = 1.5
gamma3 = 1.1
gamma4 = 0.01
gamma5 = -2.5
gamma6 = 0.01
gamma.true = c(gamma0, gamma1, gamma2, gamma3, gamma4, gamma5, gamma6)
phi_sim = exp(z \%*\% gamma.true)

range(mu_sim.sp)
range(phi_sim)

xi.true = 1.5

y_sim = rtweedie(N, xi = xi.true, mu = mu_sim.sp, phi = phi_sim)
sum(y_sim == 0)/N # proportion of zeros
y = y_sim
x = x
z = z
# mcmc parameters
niter = 1e4
nburn = niter/2
report = 1e2

# hyperparameters
lower.xi = 1
upper.xi = 2

system.time(mc_ss <- spssdglm.autograd(coords = coords, y = y, x = x, z = z,
                                    niter = niter, nburn= nburn, report = report, thin = 20,
                                    index = index, lower.xi = lower.xi, upper.xi = upper.xi,
                                    verbose = TRUE))
# Check for convergence
plot_mcmc(samples = mc_ss$xi.mcmc, true = 1.5, col = "blue", cnames = "xi")
}
}
