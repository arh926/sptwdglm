% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ssdglm.autograd.R
\name{ssdglm.autograd}
\alias{ssdglm.autograd}
\title{Spike and Slab Priors for Tweedie Compound Poisson-Gamma (CP-g) Double Generalized Linear Models}
\usage{
ssdglm.autograd(
  y = NULL,
  x = NULL,
  z = NULL,
  beta.init = NULL,
  gamma.init = NULL,
  xi.init = NULL,
  alpha.beta.init = NULL,
  alpha.gamma.init = NULL,
  zeta.beta.init = NULL,
  zeta.gamma.init = NULL,
  sigma2.beta.init = NULL,
  sigma2.gamma.init = NULL,
  shape.sigma2.beta = NULL,
  shape.sigma2.gamma = NULL,
  rate.sigma2.beta = NULL,
  rate.sigma2.gamma = NULL,
  lower.xi = NULL,
  upper.xi = NULL,
  nu0 = 1e-04,
  tau.beta = 0.1,
  tau.gamma = 0.1,
  tau.xi = 0.1,
  niter = NULL,
  nburn = NULL,
  report = NULL,
  thin = 1,
  return.mcmc = TRUE,
  verbose = FALSE,
  track = FALSE,
  digits = 3,
  reg.factor = 0
)
}
\arguments{
\item{y}{observed response}

\item{x}{covariates for the mean model}

\item{z}{covariates for the dispersion model}

\item{lower.xi}{lower bound for the index parameter, \eqn{\xi}}

\item{upper.xi}{upper bound for the index parameter, \eqn{\xi}}
}
\description{
Performs variable selection on Double Generalized Linear Model: \eqn{\log(\mu)=x^T\beta} and \eqn{\log(\phi)=z^T\gamma}. Parameters not listed below are optional.
}
\examples{
\dontrun{

# Generate Data
N = 1e3
x = z = cbind(1, rnorm(N), rnorm(N), rnorm(N),
              rnorm(N), rnorm(N), rnorm(N))
x[,-1] = apply(x[,-1], 2, function(s) (s - mean(s))/sd(s))
z[,-1] = apply(z[,-1], 2, function(s) (s - mean(s))/sd(s))
p = ncol(x)
q = ncol(z)
# covariates
beta0 = 1
beta1 = 1.5
beta2 = 1e-4
beta3 = 1.4
beta4 = 1.1
beta5 = 1e-4
beta6 = 2.5
beta.true = c(beta0, beta1, beta2, beta3, beta4, beta5, beta6)
mu_sim = exp(x \%*\% beta.true)

gamma0 = 1
gamma1 = 1e-4
gamma2 = 1.5
gamma3 = 1.1
gamma4 = 1e-4
gamma5 = -2.5
gamma6 = 1e-4
gamma.true = c(gamma0, gamma1, gamma2, gamma3, gamma4, gamma5, gamma6)
phi_sim = exp(z \%*\% gamma.true)

xi.true = 1.5

y_sim = rtweedie(N, xi = xi.true, mu = mu_sim, phi = phi_sim)
sum(y_sim == 0)/N # proportion of zeros
var(y_sim)

# # Traditional DGLM
# mdglm = try(dglm(y_sim~x[,-1],~z[,-1],family=tweedie(link.power=0, var.power=1.5)))
# if(class(mdglm) != "try-error") mdglm.mean = mdglm$coefficients # mean model
# if(class(mdglm) != "try-error") mdglm.disp = mdglm$dispersion.fit$coefficients # dispersion model

# Bayesian DGLM
y = y_sim
x = x
z = z

# hyperparameters
lower.xi = 1
upper.xi = 2

niter = 3e4
nburn = niter/2
report = 1e2

system.time(mc <- ssdglm.autograd(y = y, x = x, z = z, lower.xi = lower.xi, upper.xi = upper.xi, verbose = T,
                                 niter = niter, nburn = nburn, report= report, thin = 50))#'
# model summary
cbind(mc$model, true=c(beta.true,gamma.true,xi.true))
# mean model variance covariance matrix
round(mc$mean.cov.model, 2)
# dispersion model variance covariance matrix
round(mc$disp.cov.model, 2)

# Checks for convergence
plot_mcmc(mc$xi.mcmc, true = xi.true, cnames = "xi")
}
}
